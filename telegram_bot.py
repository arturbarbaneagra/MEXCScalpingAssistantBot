import asyncio
import time
import threading
from typing import Dict, Optional, List, Any
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton
from telegram.ext import Application, CommandHandler, ConversationHandler, MessageHandler, filters, ContextTypes, CallbackQueryHandler
from telegram.constants import ParseMode
from logger import bot_logger
from config import config_manager
from api_client import api_client
from watchlist_manager import watchlist_manager
from bot_state import bot_state_manager
from advanced_alerts import advanced_alert_manager, AlertType, AlertSeverity
import os

class TradingTelegramBot:
    def __init__(self):
        self.token = os.getenv('TELEGRAM_TOKEN')
        self.chat_id = os.getenv('TELEGRAM_CHAT_ID')

        if not self.token or not self.chat_id:
            raise ValueError("TELEGRAM_TOKEN –∏ TELEGRAM_CHAT_ID –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è")

        self.app = None
        self.bot_running = False
        self.bot_mode = None
        self.active_coins: Dict[str, Dict] = {}
        self.monitoring_message_id = None
        self.last_message_time = 0
        self.message_cache = {}
        self._notification_locks = set()
        self._processing_coins = set()  # –ó–∞—â–∏—Ç–∞ –æ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
        self._message_queue = asyncio.Queue()  # –û—á–µ—Ä–µ–¥—å —Å–æ–æ–±—â–µ–Ω–∏–π
        self._queue_processor_task = None

        # –°–æ—Å—Ç–æ—è–Ω–∏—è ConversationHandler
        self.ADDING_COIN, self.REMOVING_COIN = range(2)
        self.SETTING_VOLUME, self.SETTING_SPREAD, self.SETTING_NATR = range(2, 5)

        self._setup_keyboards()

    def _setup_keyboards(self):
        """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã"""
        self.main_keyboard = ReplyKeyboardMarkup([
            ["üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è", "üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥"],
            ["‚ûï –î–æ–±–∞–≤–∏—Ç—å", "‚ûñ –£–¥–∞–ª–∏—Ç—å"],
            ["üìã –°–ø–∏—Å–æ–∫", "‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏"],
            ["üõë –°—Ç–æ–ø", "‚Ñπ –°—Ç–∞—Ç—É—Å"]
        ], resize_keyboard=True, one_time_keyboard=False)

        self.settings_keyboard = ReplyKeyboardMarkup([
            ["üìä –û–±—ä—ë–º", "‚áÑ –°–ø—Ä–µ–¥"],
            ["üìà NATR", "üö® –ê–ª–µ—Ä—Ç—ã"],
            ["üîÑ –°–±—Ä–æ—Å", "üîô –ù–∞–∑–∞–¥"]
        ], resize_keyboard=True)

        self.back_keyboard = ReplyKeyboardMarkup([
            ["üîô –ù–∞–∑–∞–¥"]
        ], resize_keyboard=True)

    async def _start_message_queue_processor(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        try:
            # –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –æ—á–µ—Ä–µ–¥—å –≤ —Ç–µ–∫—É—â–µ–º event loop
            try:
                current_loop = asyncio.get_running_loop()
                if self._message_queue is not None:
                    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∏–≤—è–∑–∫—É –∫ event loop
                    try:
                        self._message_queue.qsize()  # –¢–µ—Å—Ç –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏
                    except RuntimeError:
                        # –û—á–µ—Ä–µ–¥—å –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ –¥—Ä—É–≥–æ–º—É loop
                        self._message_queue = None
                
                if self._message_queue is None:
                    self._message_queue = asyncio.Queue()
                    bot_logger.debug("üîÑ –°–æ–∑–¥–∞–Ω–∞ –Ω–æ–≤–∞—è –æ—á–µ—Ä–µ–¥—å —Å–æ–æ–±—â–µ–Ω–∏–π")
                    
            except Exception as e:
                bot_logger.debug(f"–ü–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏–µ –æ—á–µ—Ä–µ–¥–∏: {e}")
                self._message_queue = asyncio.Queue()

            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ä—É—é –∑–∞–¥–∞—á—É –µ—Å–ª–∏ –µ—Å—Ç—å
            if self._queue_processor_task and not self._queue_processor_task.done():
                self._queue_processor_task.cancel()
                try:
                    await self._queue_processor_task
                except asyncio.CancelledError:
                    pass

            # –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—É—é –∑–∞–¥–∞—á—É
            self._queue_processor_task = asyncio.create_task(self._process_message_queue())
            bot_logger.debug("üîÑ –ü—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π –∑–∞–ø—É—â–µ–Ω")
            
        except Exception as e:
            bot_logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–∞ –æ—á–µ—Ä–µ–¥–∏: {e}")

    async def _process_message_queue(self):
        """–û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç –æ—á–µ—Ä–µ–¥—å —Å–æ–æ–±—â–µ–Ω–∏–π –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ"""
        consecutive_errors = 0
        max_consecutive_errors = 5
        
        while self.bot_running and consecutive_errors < max_consecutive_errors:
            try:
                if self._message_queue is None:
                    await asyncio.sleep(1.0)
                    continue

                # –ñ–¥–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –æ—á–µ—Ä–µ–¥–∏ —Å —Ç–∞–π–º–∞—É—Ç–æ–º
                try:
                    message_data = await asyncio.wait_for(
                        self._message_queue.get(), 
                        timeout=2.0
                    )
                    consecutive_errors = 0  # –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –ø—Ä–∏ —É—Å–ø–µ—Ö–µ
                    
                    await self._execute_telegram_message(message_data)
                    await asyncio.sleep(0.1)  # –ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏
                    
                except asyncio.TimeoutError:
                    consecutive_errors = 0  # –¢–∞–π–º–∞—É—Ç –Ω–µ —Å—á–∏—Ç–∞–µ—Ç—Å—è –æ—à–∏–±–∫–æ–π
                    continue
                except RuntimeError as e:
                    if "different event loop" in str(e):
                        bot_logger.warning("üîÑ –ü–µ—Ä–µ–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—á–µ—Ä–µ–¥–∏ –∏–∑-–∑–∞ —Å–º–µ–Ω—ã event loop")
                        self._message_queue = asyncio.Queue()
                        consecutive_errors = 0
                        continue
                    else:
                        raise

            except Exception as e:
                consecutive_errors += 1
                bot_logger.error(f"–û—à–∏–±–∫–∞ –≤ –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä–µ –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π ({consecutive_errors}/{max_consecutive_errors}): {e}")
                await asyncio.sleep(min(0.5 * consecutive_errors, 3.0))  # –≠–∫—Å–ø–æ–Ω–µ–Ω—Ü–∏–∞–ª—å–Ω–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
        
        if consecutive_errors >= max_consecutive_errors:
            bot_logger.error("üö® –ü—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—á–µ—Ä–µ–¥–∏ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –∏–∑-–∑–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –æ—à–∏–±–æ–∫")
            self._queue_processor_task = None

    async def _execute_telegram_message(self, message_data: Dict):
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç –æ—Ç–ø—Ä–∞–≤–∫—É Telegram —Å–æ–æ–±—â–µ–Ω–∏—è"""
        try:
            action = message_data['action']

            if action == 'send':
                response = await self._direct_telegram_send(
                    message_data['text'],
                    message_data.get('reply_markup'),
                    message_data.get('parse_mode', ParseMode.HTML)
                )

                # –í–æ–∑–≤—Ä–∞—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —á–µ—Ä–µ–∑ callback –µ—Å–ª–∏ –µ—Å—Ç—å
                if 'callback' in message_data:
                    message_data['callback'](response)

            elif action == 'edit':
                await self._direct_telegram_edit(
                    message_data['message_id'],
                    message_data['text'],
                    message_data.get('reply_markup')
                )

            elif action == 'delete':
                await self._direct_telegram_delete(message_data['message_id'])

        except Exception as e:
            bot_logger.error(f"–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è Telegram –æ–ø–µ—Ä–∞—Ü–∏–∏: {e}")

    async def _direct_telegram_send(self, text: str, reply_markup=None, parse_mode=ParseMode.HTML):
        """–ü—Ä—è–º–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —á–µ—Ä–µ–∑ Telegram API"""
        if not self.app or not self.app.bot:
            return None

        try:
            current_time = time.time()
            if current_time - self.last_message_time < 0.5:
                await asyncio.sleep(0.5 - (current_time - self.last_message_time))

            message = await self.app.bot.send_message(
                chat_id=self.chat_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=parse_mode
            )

            self.last_message_time = time.time()

            if message and hasattr(message, 'message_id'):
                return message.message_id
            return None

        except Exception as e:
            bot_logger.debug(f"–ü—Ä—è–º–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å: {type(e).__name__}")
            return None

    async def _direct_telegram_edit(self, message_id: int, text: str, reply_markup=None):
        """–ü—Ä—è–º–æ–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —á–µ—Ä–µ–∑ Telegram API"""
        if not self.app or not self.app.bot:
            return

        try:
            await self.app.bot.edit_message_text(
                chat_id=self.chat_id,
                message_id=message_id,
                text=text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.HTML
            )
        except Exception as e:
            if "message is not modified" not in str(e).lower():
                bot_logger.debug(f"–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è {message_id} –Ω–µ —É–¥–∞–ª–æ—Å—å: {type(e).__name__}")

    async def _direct_telegram_delete(self, message_id: int):
        """–ü—Ä—è–º–æ–µ —É–¥–∞–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Telegram API"""
        if not self.app or not self.app.bot:
            return

        try:
            await self.app.bot.delete_message(chat_id=self.chat_id, message_id=message_id)
            if message_id in self.message_cache:
                del self.message_cache[message_id]
        except Exception as e:
            bot_logger.debug(f"–£–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è {message_id} –Ω–µ —É–¥–∞–ª–æ—Å—å: {type(e).__name__}")

    async def send_message(self, text: str, reply_markup=None, parse_mode=ParseMode.HTML) -> Optional[int]:
        """–û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –æ—á–µ—Ä–µ–¥—å —Å callback –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞"""
        if not self.bot_running:
            return None

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –æ—á–µ—Ä–µ–¥–∏
        if self._message_queue is None:
            bot_logger.warning("–û—á–µ—Ä–µ–¥—å –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞, –ø—Ä—è–º–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞")
            return await self._direct_telegram_send(text, reply_markup, parse_mode)

        # –°–æ–∑–¥–∞–µ–º Future –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞
        result_future = asyncio.Future()

        def callback(result):
            if not result_future.done():
                result_future.set_result(result)

        # –î–æ–±–∞–≤–ª—è–µ–º –≤ –æ—á–µ—Ä–µ–¥—å
        message_data = {
            'action': 'send',
            'text': text,
            'reply_markup': reply_markup,
            'parse_mode': parse_mode,
            'callback': callback
        }

        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –æ—á–µ—Ä–µ–¥—å
            try:
                await self._message_queue.put(message_data)
            except RuntimeError as e:
                if "different event loop" in str(e):
                    bot_logger.warning("Event loop –∫–æ–Ω—Ñ–ª–∏–∫—Ç, –ø—Ä—è–º–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞")
                    return await self._direct_telegram_send(text, reply_markup, parse_mode)
                else:
                    raise
            
            # –ñ–¥–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Å —Ç–∞–π–º–∞—É—Ç–æ–º
            result = await asyncio.wait_for(result_future, timeout=10.0)

            if result:
                bot_logger.info(f"[SEND_MESSAGE_SUCCESS] –°–æ–æ–±—â–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ —É—Å–ø–µ—à–Ω–æ, msg_id: {result}")
            return result

        except asyncio.TimeoutError:
            bot_logger.error("[SEND_MESSAGE_TIMEOUT] –¢–∞–π–º–∞—É—Ç –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è")
            return None
        except Exception as e:
            bot_logger.error(f"[SEND_MESSAGE_ERROR] –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏: {e}")
            # Fallback –Ω–∞ –ø—Ä—è–º—É—é –æ—Ç–ø—Ä–∞–≤–∫—É
            return await self._direct_telegram_send(text, reply_markup, parse_mode)

    async def edit_message(self, message_id: int, text: str, reply_markup=None):
        """–†–µ–¥–∞–∫—Ç–∏—Ä—É–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –æ—á–µ—Ä–µ–¥—å"""
        if not self.bot_running:
            return

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –∫–µ—à–µ
        cached_message = self.message_cache.get(message_id)
        if cached_message == text:
            return

        message_data = {
            'action': 'edit',
            'message_id': message_id,
            'text': text,
            'reply_markup': reply_markup
        }

        try:
            await self._message_queue.put(message_data)
            self.message_cache[message_id] = text
        except Exception as e:
            bot_logger.debug(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è edit –≤ –æ—á–µ—Ä–µ–¥—å: {e}")

    async def delete_message(self, message_id: int) -> bool:
        """–£–¥–∞–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –æ—á–µ—Ä–µ–¥—å"""
        if not message_id or not isinstance(message_id, int) or message_id <= 0:
            return False

        if not self.bot_running:
            return False

        message_data = {
            'action': 'delete',
            'message_id': message_id
        }

        try:
            await self._message_queue.put(message_data)
            return True
        except Exception as e:
            bot_logger.debug(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è delete –≤ –æ—á–µ—Ä–µ–¥—å: {e}")
            return False

    def _chunks(self, lst: List, size: int):
        """–†–∞–∑–±–∏–≤–∞–µ—Ç —Å–ø–∏—Å–æ–∫ –Ω–∞ —á–∞–Ω–∫–∏"""
        for i in range(0, len(lst), size):
            yield lst[i:i + size]

    async def _stop_current_mode(self):
        """–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Ç–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º —Ä–∞–±–æ—Ç—ã –±–æ—Ç–∞"""
        if self.bot_mode:
            bot_logger.info(f"üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ä–µ–∂–∏–º–∞: {self.bot_mode}")

            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ü–∏–∫–ª—ã
            self.bot_running = False
            await asyncio.sleep(1.0)

            # –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—á–µ—Ä–µ–¥–∏
            if self._queue_processor_task and not self._queue_processor_task.done():
                self._queue_processor_task.cancel()
                try:
                    await asyncio.wait_for(self._queue_processor_task, timeout=2.0)
                except (asyncio.CancelledError, asyncio.TimeoutError):
                    pass
                self._queue_processor_task = None

            # –ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –æ—á–µ—Ä–µ–¥–∏
            if self._message_queue is not None:
                try:
                    while not self._message_queue.empty():
                        try:
                            self._message_queue.get_nowait()
                        except asyncio.QueueEmpty:
                            break
                        except RuntimeError:
                            # –û—á–µ—Ä–µ–¥—å –ø—Ä–∏–≤—è–∑–∞–Ω–∞ –∫ –¥—Ä—É–≥–æ–º—É event loop
                            break
                except Exception as e:
                    bot_logger.debug(f"–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ –æ—á–µ—Ä–µ–¥–∏: {e}")
                
                # –ü–µ—Ä–µ—Å–æ–∑–¥–∞–µ–º –æ—á–µ—Ä–µ–¥—å –¥–ª—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
                try:
                    self._message_queue = asyncio.Queue()
                except Exception as e:
                    bot_logger.debug(f"–û—à–∏–±–∫–∞ –ø–µ—Ä–µ—Å–æ–∑–¥–∞–Ω–∏—è –æ—á–µ—Ä–µ–¥–∏: {e}")
                    self._message_queue = None

            # –û—á–∏—â–∞–µ–º –∞–∫—Ç–∏–≤–Ω—ã–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è
            deleted_count = 0
            for symbol, coin_data in list(self.active_coins.items()):
                msg_id = coin_data.get('msg_id')
                if msg_id and isinstance(msg_id, int) and msg_id > 0:
                    try:
                        await self._direct_telegram_delete(msg_id)
                        deleted_count += 1
                    except Exception as e:
                        bot_logger.debug(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è {symbol}: {e}")

            if deleted_count > 0:
                bot_logger.info(f"üóë –£–¥–∞–ª–µ–Ω–æ {deleted_count} —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")

            # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞
            if self.monitoring_message_id:
                try:
                    await self._direct_telegram_delete(self.monitoring_message_id)
                    bot_logger.info("üìù –°–æ–æ–±—â–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —É–¥–∞–ª–µ–Ω–æ")
                except Exception as e:
                    bot_logger.debug(f"–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: {e}")
                self.monitoring_message_id = None

            # –ü–æ–ª–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è
            self._force_clear_state()

            # –ó–∞–∫—Ä—ã–≤–∞–µ–º API —Å–µ—Å—Å–∏—é
            try:
                await api_client.close()
                await asyncio.sleep(0.2)
            except Exception as e:
                bot_logger.debug(f"–û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è API: {e}")

    def _force_clear_state(self):
        """–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ –≤—Å–µ—Ö —Å–æ—Å—Ç–æ—è–Ω–∏–π"""
        self.monitoring_message_id = None
        self.active_coins.clear()
        self.message_cache.clear()
        self.bot_mode = None
        self._notification_locks.clear()
        self._processing_coins.clear()

        bot_state_manager.set_last_mode(None)
        bot_logger.debug("üßπ –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—á–∏—Å—Ç–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞")

    async def _notification_mode_loop(self):
        """–¶–∏–∫–ª —Ä–µ–∂–∏–º–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è"""
        bot_logger.info("–ó–∞–ø—É—â–µ–Ω —Ä–µ–∂–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
        await self._start_message_queue_processor()

        cleanup_counter = 0

        while self.bot_running and self.bot_mode == 'notification':
            watchlist = watchlist_manager.get_all()
            if not watchlist:
                await asyncio.sleep(config_manager.get('CHECK_FULL_CYCLE_INTERVAL'))
                continue

            # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞
            cleanup_counter += 1
            if cleanup_counter >= 10:
                await self._cleanup_stale_processes()
                cleanup_counter = 0

            batch_size = config_manager.get('CHECK_BATCH_SIZE')
            for batch in self._chunks(list(watchlist), batch_size):
                if not self.bot_running or self.bot_mode != 'notification':
                    break

                # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –±–∞—Ç—á–∞
                batch_data = await api_client.get_batch_coin_data(batch)

                # –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—É—é –º–æ–Ω–µ—Ç—É —Å –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
                for symbol, data in batch_data.items():
                    if not self.bot_running or self.bot_mode != 'notification':
                        break

                    if not data:
                        continue

                    # –ó–∞—â–∏—Ç–∞ –æ—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏ –æ–¥–Ω–æ–π –º–æ–Ω–µ—Ç—ã
                    if symbol in self._processing_coins:
                        continue

                    try:
                        self._processing_coins.add(symbol)
                        await self._process_coin_notification(symbol, data)
                        await asyncio.sleep(0.01)
                    except Exception as e:
                        bot_logger.error(f"–û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ {symbol}: {e}")
                    finally:
                        self._processing_coins.discard(symbol)

                await asyncio.sleep(config_manager.get('CHECK_BATCH_INTERVAL'))

            await asyncio.sleep(config_manager.get('CHECK_FULL_CYCLE_INTERVAL'))

    async def _cleanup_stale_processes(self):
        """–û—á–∏—Å—Ç–∫–∞ –∑–∞–≤–∏—Å—à–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤"""
        current_time = time.time()
        to_remove = []

        for symbol, coin_info in list(self.active_coins.items()):
            # –ú–æ–Ω–µ—Ç—ã –±–µ–∑ msg_id (orphaned)
            if not coin_info.get('msg_id') and not coin_info.get('creating', False):
                to_remove.append(symbol)
            # –ó–∞–≤–∏—Å—à–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã —Å–æ–∑–¥–∞–Ω–∏—è (–±–æ–ª—å—à–µ 10 —Å–µ–∫—É–Ω–¥)
            elif coin_info.get('creating', False):
                start_time = coin_info.get('creation_start', current_time)
                if current_time - start_time > 10:
                    to_remove.append(symbol)

        for symbol in to_remove:
            try:
                del self.active_coins[symbol]
                bot_logger.info(f"[CLEANUP] –û—á–∏—â–µ–Ω–∞ –∑–∞–≤–∏—Å—à–∞—è –º–æ–Ω–µ—Ç–∞ {symbol}")
            except Exception as e:
                bot_logger.error(f"[CLEANUP] –û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏ {symbol}: {e}")

        # –û—á–∏—Å—Ç–∫–∞ —Å—Ç–∞—Ä—ã—Ö –±–ª–æ–∫–∏—Ä–æ–≤–æ–∫
        self._processing_coins.clear()

    async def _process_coin_notification(self, symbol: str, data: Dict):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –º–æ–Ω–µ—Ç —Å –ø–æ–ª–Ω–æ–π –∑–∞—â–∏—Ç–æ–π –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è"""
        now = time.time()

        # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–ª–µ—Ä—Ç—ã
        try:
            from advanced_alerts import advanced_alert_manager
            advanced_alert_manager.check_coin_alerts(symbol, data)
        except:
            pass

        if data['active']:
            # –ú–æ–Ω–µ—Ç–∞ –∞–∫—Ç–∏–≤–Ω–∞
            if symbol not in self.active_coins:
                # –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞ –æ—Ç –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏—è
                if symbol in self._notification_locks:
                    return

                self._notification_locks.add(symbol)

                try:
                    await self._create_coin_notification(symbol, data, now)
                finally:
                    self._notification_locks.discard(symbol)
            else:
                # –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â—É—é –º–æ–Ω–µ—Ç—É
                await self._update_coin_notification(symbol, data, now)
        else:
            # –ú–æ–Ω–µ—Ç–∞ –Ω–µ–∞–∫—Ç–∏–≤–Ω–∞ - –ø—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
            if symbol in self.active_coins:
                coin_info = self.active_coins[symbol]

                # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ —Å–æ–∑–¥–∞–µ—Ç—Å—è
                if coin_info.get('creating', False):
                    return

                inactivity_timeout = config_manager.get('INACTIVITY_TIMEOUT')
                if now - coin_info['last_active'] > inactivity_timeout:
                    await self._end_coin_activity(symbol, now)

    async def _create_coin_notification(self, symbol: str, data: Dict, now: float):
        """–°–æ–∑–¥–∞–µ—Ç –Ω–æ–≤–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –¥–ª—è –º–æ–Ω–µ—Ç—ã"""
        bot_logger.info(f"[NOTIFICATION_START] {symbol} - –Ω–æ–≤–∞—è –∞–∫—Ç–∏–≤–Ω–∞—è –º–æ–Ω–µ—Ç–∞ –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∞")

        # –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å —Å —Ñ–ª–∞–≥–æ–º creating
        self.active_coins[symbol] = {
            'start': now,
            'last_active': now,
            'data': data.copy(),
            'creating': True,
            'creation_start': now
        }

        # –°–æ–∑–¥–∞–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        message = (
            f"üö® <b>{symbol}_USDT –∞–∫—Ç–∏–≤–µ–Ω</b>\n"
            f"üîÑ –ò–∑–º: {data['change']:+.2f}%  üîÅ –°–¥–µ–ª–æ–∫: {data['trades']}\n"
            f"üìä –û–±—ä—ë–º: ${data['volume']:,.2f}  NATR: {data['natr']:.2f}%\n"
            f"‚áÑ –°–ø—Ä–µ–¥: {data['spread']:.2f}%"
        )

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ
        msg_id = await self.send_message(message)

        if msg_id and symbol in self.active_coins:  # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ –∑–∞–ø–∏—Å—å –µ—â–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            # –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–ø–∏—Å—å —Å –ø–æ–ª—É—á–µ–Ω–Ω—ã–º msg_id
            self.active_coins[symbol].update({
                'msg_id': msg_id,
                'creating': False
            })
            self.message_cache[msg_id] = message
            bot_logger.trade_activity(symbol, "STARTED", f"Volume: ${data['volume']:,.2f}")
            bot_logger.info(f"[NOTIFICATION_SUCCESS] {symbol} - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ —Å–æ–∑–¥–∞–Ω–æ —É—Å–ø–µ—à–Ω–æ")
        else:
            # –£–¥–∞–ª—è–µ–º –Ω–µ—É–¥–∞—á–Ω—É—é –∑–∞–ø–∏—Å—å
            if symbol in self.active_coins:
                del self.active_coins[symbol]
            bot_logger.warning(f"[NOTIFICATION_FAILED] {symbol} - –Ω–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ")

    async def _update_coin_notification(self, symbol: str, data: Dict, now: float):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ"""
        coin_info = self.active_coins[symbol]

        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –µ—Å–ª–∏ —Å–æ–∑–¥–∞–µ—Ç—Å—è
        if coin_info.get('creating', False):
            return

        # –û–±–Ω–æ–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ
        coin_info['last_active'] = now
        coin_info['data'] = data

        # –û–±–Ω–æ–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –µ—Å–ª–∏ –µ—Å—Ç—å msg_id
        msg_id = coin_info.get('msg_id')
        if msg_id and isinstance(msg_id, int):
            new_message = (
                f"üö® <b>{symbol}_USDT –∞–∫—Ç–∏–≤–µ–Ω</b>\n"
                f"üîÑ –ò–∑–º: {data['change']:+.2f}%  üîÅ –°–¥–µ–ª–æ–∫: {data['trades']}\n"
                f"üìä –û–±—ä—ë–º: ${data['volume']:,.2f}  NATR: {data['natr']:.2f}%\n"
                f"‚áÑ –°–ø—Ä–µ–¥: {data['spread']:.2f}%"
            )

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–∏—è –ø–µ—Ä–µ–¥ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ–º
            cached_message = self.message_cache.get(msg_id)
            if cached_message != new_message:
                await self.edit_message(msg_id, new_message)

    async def _end_coin_activity(self, symbol: str, end_time: float):
        """–ó–∞–≤–µ—Ä—à–∞–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –º–æ–Ω–µ—Ç—ã"""
        if symbol not in self.active_coins:
            return

        coin_info = self.active_coins[symbol]
        duration = end_time - coin_info['start']

        bot_logger.info(f"[END] –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ {symbol}, –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration:.1f}—Å")

        # –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        msg_id = coin_info.get('msg_id')
        if msg_id and isinstance(msg_id, int) and msg_id > 0:
            await self.delete_message(msg_id)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –µ—Å–ª–∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –±—ã–ª–∞ >= 60 —Å–µ–∫—É–Ω–¥
        if duration >= 60:
            duration_min = int(duration // 60)
            duration_sec = int(duration % 60)
            end_message = (
                f"‚úÖ <b>{symbol}_USDT –∑–∞–≤–µ—Ä—à–∏–ª –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å</b>\n"
                f"‚è± –î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {duration_min} –º–∏–Ω {duration_sec} —Å–µ–∫"
            )
            await self.send_message(end_message)
            bot_logger.trade_activity(symbol, "ENDED", f"Duration: {duration_min}m {duration_sec}s")

        # –£–¥–∞–ª—è–µ–º –∏–∑ –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–µ—Ç
        del self.active_coins[symbol]

    async def _monitoring_mode_loop(self):
        """–¶–∏–∫–ª —Ä–µ–∂–∏–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        bot_logger.info("–ó–∞–ø—É—â–µ–Ω —Ä–µ–∂–∏–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞")

        # –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å–æ—Ä –æ—á–µ—Ä–µ–¥–∏ —Å–æ–æ–±—â–µ–Ω–∏–π
        await self._start_message_queue_processor()

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
        initial_text = "üîÑ <b>–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞...</b>"
        self.monitoring_message_id = await self.send_message(initial_text)

        cycle_count = 0
        while self.bot_running and self.bot_mode == 'monitoring':
            cycle_count += 1

            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–∏—Å–æ–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è
            watchlist = watchlist_manager.get_all()
            if not watchlist:
                no_coins_text = "‚ùå <b>–°–ø–∏—Å–æ–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—É—Å—Ç</b>\n–î–æ–±–∞–≤—å—Ç–µ –º–æ–Ω–µ—Ç—ã –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞."
                if self.monitoring_message_id:
                    await self.edit_message(self.monitoring_message_id, no_coins_text)
                await asyncio.sleep(config_manager.get('MONITORING_UPDATE_INTERVAL'))
                continue

            # –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –º–æ–Ω–µ—Ç
            try:
                results, failed_coins = await self._fetch_monitoring_data()

                # –û–±–Ω–æ–≤–ª—è–µ–º –æ—Ç—á–µ—Ç
                if results:
                    report = self._format_monitoring_report(results, failed_coins)
                    if self.monitoring_message_id:
                        await self.edit_message(self.monitoring_message_id, report)
                    else:
                        self.monitoring_message_id = await self.send_message(report)

                # –ü–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–∞—è –æ—á–∏—Å—Ç–∫–∞
                if cycle_count % 50 == 0:
                    import gc
                    gc.collect()
                    from cache_manager import cache_manager
                    cache_manager.clear_expired()

            except Exception as e:
                bot_logger.error(f"–û—à–∏–±–∫–∞ –≤ —Ü–∏–∫–ª–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞: {e}")

            await asyncio.sleep(config_manager.get('MONITORING_UPDATE_INTERVAL'))

    async def _fetch_monitoring_data(self):
        """–ü–æ–ª—É—á–∞–µ—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        watchlist = list(watchlist_manager.get_all())
        results = []
        failed_coins = []

        batch_size = config_manager.get('CHECK_BATCH_SIZE', 15)
        for batch in self._chunks(watchlist, batch_size):
            if not self.bot_running or self.bot_mode != 'monitoring':
                break

            try:
                batch_data = await api_client.get_batch_coin_data(batch)
                for symbol, coin_data in batch_data.items():
                    if coin_data:
                        results.append(coin_data)
                    else:
                        failed_coins.append(symbol)
            except Exception as e:
                bot_logger.error(f"–û—à–∏–±–∫–∞ batch –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö: {e}")
                failed_coins.extend(batch)

            await asyncio.sleep(config_manager.get('CHECK_BATCH_INTERVAL', 0.4))

        return results, failed_coins

    def _format_monitoring_report(self, results: List[Dict], failed_coins: List[str]) -> str:
        """–§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç –æ—Ç—á–µ—Ç –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        results.sort(key=lambda x: x['volume'], reverse=True)

        parts = ["<b>üìä –°–∫–∞–ª—å–ø–∏–Ω–≥ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ (1–º –¥–∞–Ω–Ω—ã–µ)</b>\n"]

        vol_thresh = config_manager.get('VOLUME_THRESHOLD')
        spread_thresh = config_manager.get('SPREAD_THRESHOLD')
        natr_thresh = config_manager.get('NATR_THRESHOLD')

        parts.append(
            f"<i>–§–∏–ª—å—Ç—Ä—ã: 1–º –æ–±–æ—Ä–æ—Ç ‚â•${vol_thresh:,}, "
            f"–°–ø—Ä–µ–¥ ‚â•{spread_thresh}%, NATR ‚â•{natr_thresh}%</i>\n"
        )

        if failed_coins:
            parts.append(f"‚ö† <i>–û—à–∏–±–∫–∏: {', '.join(failed_coins[:5])}</i>\n")

        active_coins = [r for r in results if r['active']]
        if active_coins:
            parts.append("<b>üü¢ –ê–ö–¢–ò–í–ù–´–ï:</b>")
            for coin in active_coins[:10]:
                trades_icon = "üî•" if coin.get('has_recent_trades') else "üìä"
                parts.append(
                    f"‚Ä¢ <b>{coin['symbol']}</b> "
                    f"${coin['volume']:,.0f} | {coin['change']:+.1f}% | "
                    f"{trades_icon}T:{coin['trades']} | S:{coin['spread']:.2f}% | N:{coin['natr']:.2f}%"
                )
            parts.append("")

        inactive_coins = [r for r in results if not r['active']]
        if inactive_coins:
            parts.append("<b>üî¥ –ù–ï–ê–ö–¢–ò–í–ù–´–ï (—Ç–æ–ø –ø–æ –æ–±—ä—ë–º—É):</b>")
            for coin in inactive_coins[:8]:
                trades_status = "‚úÖ" if coin['trades'] > 0 else "‚ùå"
                parts.append(
                    f"‚Ä¢ <b>{coin['symbol']}</b> "
                    f"${coin['volume']:,.0f} | {coin['change']:+.1f}% | "
                    f"{trades_status}T:{coin['trades']} | S:{coin['spread']:.2f}% | N:{coin['natr']:.2f}%"
                )

        parts.append(f"\nüìà –ê–∫—Ç–∏–≤–Ω—ã—Ö: {len(active_coins)}/{len(results)}")

        report = "\n".join(parts)
        if len(report) > 4000:
            report = report[:4000] + "\n... <i>(–æ—Ç—á–µ—Ç –æ–±—Ä–µ–∑–∞–Ω)</i>"

        return report

    def start_monitoring_loop(self):
        """–ó–∞–ø—É—Å–∫–∞–µ—Ç —Ü–∏–∫–ª –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ"""
        def run_loop():
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)

            if self.bot_mode == 'notification':
                loop.run_until_complete(self._notification_mode_loop())
            elif self.bot_mode == 'monitoring':
                loop.run_until_complete(self._monitoring_mode_loop())

        thread = threading.Thread(target=run_loop, daemon=True)
        thread.start()
        return thread

    # Telegram Handlers
    async def start_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–æ–º–∞–Ω–¥—ã /start"""
        last_mode = bot_state_manager.get_last_mode()

        welcome_text = (
            "ü§ñ <b>–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ç–æ—Ä–≥–æ–≤—ã–π –±–æ—Ç!</b>\n\n"
            "üìä <b>–†–µ–∂–∏–º—ã —Ä–∞–±–æ—Ç—ã:</b>\n"
            "‚Ä¢ üîî <b>–£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è</b> - –æ–ø–æ–≤–µ—â–µ–Ω–∏—è –æ–± –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–µ—Ç–∞—Ö\n"
            "‚Ä¢ üìä <b>–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥</b> - –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞\n\n"
            "‚öô <b>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ:</b>\n"
            "‚Ä¢ ‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–µ—Ç—É –≤ —Å–ø–∏—Å–æ–∫\n"
            "‚Ä¢ ‚ûñ –£–¥–∞–ª–∏—Ç—å –º–æ–Ω–µ—Ç—É –∏–∑ —Å–ø–∏—Å–∫–∞\n"
            "‚Ä¢ üìã –ü–æ–∫–∞–∑–∞—Ç—å —Å–ø–∏—Å–æ–∫ –º–æ–Ω–µ—Ç\n"
            "‚Ä¢ ‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤\n\n"
        )

        # –ê–≤—Ç–æ–≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Ä–µ–∂–∏–º–∞
        if last_mode and not self.bot_running:
            if last_mode == 'notification':
                welcome_text += "üîÑ <b>–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é —Ä–µ–∂–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π...</b>\n\n"
                await update.message.reply_text(welcome_text + "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=self.main_keyboard, parse_mode=ParseMode.HTML)

                self.bot_mode = 'notification'
                self.bot_running = True
                self.start_monitoring_loop()

                await self.send_message(
                    "‚úÖ <b>–†–µ–∂–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>\n"
                    "–í—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–µ—Ç–∞—Ö."
                )
                return

            elif last_mode == 'monitoring':
                welcome_text += "üîÑ <b>–í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é —Ä–µ–∂–∏–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞...</b>\n\n"
                await update.message.reply_text(welcome_text + "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:", reply_markup=self.main_keyboard, parse_mode=ParseMode.HTML)

                self.bot_mode = 'monitoring'
                self.bot_running = True
                self.start_monitoring_loop()

                await self.send_message(
                    "‚úÖ <b>–†–µ–∂–∏–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>\n"
                    "–°–≤–æ–¥–∫–∞ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏."
                )
                return

        welcome_text += "–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:"
        await update.message.reply_text(welcome_text, reply_markup=self.main_keyboard, parse_mode=ParseMode.HTML)

    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û—Å–Ω–æ–≤–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç—á–∏–∫ –∫–Ω–æ–ø–æ–∫"""
        text = update.message.text

        try:
            if text == "üîî –£–≤–µ–¥–æ–º–ª–µ–Ω–∏—è":
                await self._handle_notification_mode(update)
            elif text == "üìä –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥":
                await self._handle_monitoring_mode(update)
            elif text == "üõë –°—Ç–æ–ø":
                await self._handle_stop(update)
            elif text == "‚ûï –î–æ–±–∞–≤–∏—Ç—å":
                return await self._handle_add_coin_start(update)
            elif text == "‚ûñ –£–¥–∞–ª–∏—Ç—å":
                return await self._handle_remove_coin_start(update)
            elif text == "üìã –°–ø–∏—Å–æ–∫":
                await self._handle_show_list(update)
            elif text == "‚öô –ù–∞—Å—Ç—Ä–æ–π–∫–∏":
                await self._handle_settings(update)
            elif text == "üìä –û–±—ä—ë–º":
                return await self._handle_volume_setting_start(update)
            elif text == "‚áÑ –°–ø—Ä–µ–¥":
                return await self._handle_spread_setting_start(update)
            elif text == "üìà NATR":
                return await self._handle_natr_setting_start(update)
            elif text == "üö® –ê–ª–µ—Ä—Ç—ã":
                await self._handle_alerts(update)
            elif text == "üîÑ –°–±—Ä–æ—Å":
                await self._handle_reset_settings(update)
            elif text == "‚Ñπ –°—Ç–∞—Ç—É—Å":
                await self._handle_status(update)
            elif text == "üîô –ù–∞–∑–∞–¥":
                await self._handle_back(update)
            else:
                await update.message.reply_text(
                    "‚ùì –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –º–µ–Ω—é.",
                    reply_markup=self.main_keyboard
                )
        except Exception as e:
            bot_logger.error(f"–û—à–∏–±–∫–∞ –≤ button_handler: {e}", exc_info=True)
            await update.message.reply_text(
                "‚ùå –ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑.",
                reply_markup=self.main_keyboard
            )

        return ConversationHandler.END

    async def _handle_notification_mode(self, update: Update):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∂–∏–º–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π"""
        if self.bot_running and self.bot_mode == 'notification':
            await update.message.reply_text(
                "‚úÖ –ë–æ—Ç —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∂–∏–º–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π.",
                reply_markup=self.main_keyboard
            )
            return

        await self._stop_current_mode()
        await asyncio.sleep(1.0)

        await update.message.reply_text(
            "‚úÖ <b>–†–µ–∂–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω</b>\n"
            "–í—ã –±—É–¥–µ—Ç–µ –ø–æ–ª—É—á–∞—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ–± –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–µ—Ç–∞—Ö.\n"
            "üöÄ <i>–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Å–∫–∞–ª—å–ø–∏–Ω–≥–∞</i>",
            reply_markup=self.main_keyboard,
            parse_mode=ParseMode.HTML
        )

        await asyncio.sleep(0.3)

        self.bot_mode = 'notification'
        self.bot_running = True
        bot_state_manager.set_last_mode('notification')
        self.start_monitoring_loop()

        bot_logger.info("üîî –†–µ–∂–∏–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")

    async def _handle_monitoring_mode(self, update: Update):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–µ–∂–∏–º–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞"""
        if self.bot_running and self.bot_mode == 'monitoring':
            await update.message.reply_text(
                "‚úÖ –ë–æ—Ç —É–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∂–∏–º–µ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞.",
                reply_markup=self.main_keyboard
            )
            return

        await self._stop_current_mode()
        await asyncio.sleep(1.0)

        await update.message.reply_text(
            "‚úÖ <b>–†–µ–∂–∏–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω</b>\n"
            "–°–≤–æ–¥–∫–∞ –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏.\n"
            "üöÄ <i>–û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω –¥–ª—è —Å–∫–∞–ª—å–ø–∏–Ω–≥–∞</i>",
            reply_markup=self.main_keyboard,
            parse_mode=ParseMode.HTML
        )

        await asyncio.sleep(0.3)

        self.bot_mode = 'monitoring'
        self.bot_running = True
        bot_state_manager.set_last_mode('monitoring')
        self.start_monitoring_loop()

        bot_logger.info("üìä –†–µ–∂–∏–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ —É—Å–ø–µ—à–Ω–æ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω")

    async def _handle_stop(self, update: Update):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –±–æ—Ç–∞"""
        await self._stop_current_mode()
        await update.message.reply_text(
            "üõë <b>–ë–æ—Ç –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω</b>",
            reply_markup=self.main_keyboard,
            parse_mode=ParseMode.HTML
        )

    async def _handle_add_coin_start(self, update: Update):
        """–ù–∞—á–∞–ª–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç—ã"""
        await self._stop_current_mode()
        await update.message.reply_text(
            "‚ûï <b>–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç—ã</b>\n\n"
            "–í–≤–µ–¥–∏—Ç–µ —Å–∏–º–≤–æ–ª –º–æ–Ω–µ—Ç—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä: <code>BTC</code> –∏–ª–∏ <code>BTC_USDT</code>):",
            reply_markup=self.back_keyboard,
            parse_mode=ParseMode.HTML
        )
        return self.ADDING_COIN

    async def _handle_remove_coin_start(self, update: Update):
        """–ù–∞—á–∞–ª–æ —É–¥–∞–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç—ã"""
        await self._stop_current_mode()

        if watchlist_manager.size() == 0:
            await update.message.reply_text(
                "‚ùå –°–ø–∏—Å–æ–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—É—Å—Ç.",
                reply_markup=self.main_keyboard
            )
            return ConversationHandler.END

        coins_list = ", ".join(sorted(watchlist_manager.get_all())[:10])
        if watchlist_manager.size() > 10:
            coins_list += "..."

        await update.message.reply_text(
            f"‚ûñ <b>–£–¥–∞–ª–µ–Ω–∏–µ –º–æ–Ω–µ—Ç—ã</b>\n\n"
            f"–¢–µ–∫—É—â–∏–π —Å–ø–∏—Å–æ–∫: {coins_list}\n\n"
            f"–í–≤–µ–¥–∏—Ç–µ —Å–∏–º–≤–æ–ª –º–æ–Ω–µ—Ç—ã –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è:",
            reply_markup=self.back_keyboard,
            parse_mode=ParseMode.HTML
        )
        return self.REMOVING_COIN

    async def _handle_volume_setting_start(self, update: Update):
        """–ù–∞—á–∞–ª–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±—ä—ë–º–∞"""
        await self._stop_current_mode()
        current_value = config_manager.get('VOLUME_THRESHOLD')
        await update.message.reply_text(
            f"üìä <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –æ–±—ä—ë–º–∞</b>\n\n"
            f"–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: <code>${current_value:,}</code>\n\n"
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –¥–æ–ª–ª–∞—Ä–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä: 1500):",
            reply_markup=self.back_keyboard,
            parse_mode=ParseMode.HTML
        )
        return self.SETTING_VOLUME

    async def _handle_spread_setting_start(self, update: Update):
        """–ù–∞—á–∞–ª–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–ø—Ä–µ–¥–∞"""
        await self._stop_current_mode()
        current_value = config_manager.get('SPREAD_THRESHOLD')
        await update.message.reply_text(
            f"‚áÑ <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ —Å–ø—Ä–µ–¥–∞</b>\n\n"
            f"–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: <code>{current_value}%</code>\n\n"
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä: 0.2):",
            reply_markup=self.back_keyboard,
            parse_mode=ParseMode.HTML
        )
        return self.SETTING_SPREAD

    async def _handle_natr_setting_start(self, update: Update):
        """–ù–∞—á–∞–ª–æ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ NATR"""
        await self._stop_current_mode()
        current_value = config_manager.get('NATR_THRESHOLD')
        await update.message.reply_text(
            f"üìà <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ NATR</b>\n\n"
            f"–¢–µ–∫—É—â–µ–µ –∑–Ω–∞—á–µ–Ω–∏–µ: <code>{current_value}%</code>\n\n"
            f"–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ –≤ –ø—Ä–æ—Ü–µ–Ω—Ç–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä: 0.8):",
            reply_markup=self.back_keyboard,
            parse_mode=ParseMode.HTML
        )
        return self.SETTING_NATR

    async def _handle_show_list(self, update: Update):
        """–ü–æ–∫–∞–∑ —Å–ø–∏—Å–∫–∞ –º–æ–Ω–µ—Ç"""
        await self._stop_current_mode()

        coins = watchlist_manager.get_all()
        if not coins:
            text = "üìã <b>–°–ø–∏—Å–æ–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è –ø—É—Å—Ç</b>"
        else:
            sorted_coins = sorted(coins)
            text = f"üìã <b>–°–ø–∏—Å–æ–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è ({len(coins)} –º–æ–Ω–µ—Ç):</b>\n\n"

            for i in range(0, len(sorted_coins), 5):
                batch = sorted_coins[i:i+5]
                text += " ‚Ä¢ ".join(batch) + "\n"

        await update.message.reply_text(text, reply_markup=self.main_keyboard, parse_mode=ParseMode.HTML)

    async def _handle_settings(self, update: Update):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞—Å—Ç—Ä–æ–µ–∫"""
        await self._stop_current_mode()

        current_settings = (
            "‚öô <b>–¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤:</b>\n\n"
            f"üìä –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–±—ä—ë–º: <code>${config_manager.get('VOLUME_THRESHOLD'):,}</code>\n"
            f"‚áÑ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å–ø—Ä–µ–¥: <code>{config_manager.get('SPREAD_THRESHOLD')}%</code>\n"
            f"üìà –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π NATR: <code>{config_manager.get('NATR_THRESHOLD')}%</code>\n\n"
            "–í—ã–±–µ—Ä–∏—Ç–µ –ø–∞—Ä–∞–º–µ—Ç—Ä –¥–ª—è –∏–∑–º–µ–Ω–µ–Ω–∏—è:"
        )

        await update.message.reply_text(
            current_settings,
            reply_markup=self.settings_keyboard,
            parse_mode=ParseMode.HTML
        )

    async def _handle_status(self, update: Update):
        """–ü–æ–∫–∞–∑ —Å—Ç–∞—Ç—É—Å–∞ –±–æ—Ç–∞"""
        status_parts = ["‚Ñπ <b>–°—Ç–∞—Ç—É—Å –±–æ—Ç–∞:</b>\n"]

        if self.bot_running:
            status_parts.append(f"üü¢ –†–∞–±–æ—Ç–∞–µ—Ç –≤ —Ä–µ–∂–∏–º–µ: <b>{self.bot_mode}</b>")
            if self.bot_mode == 'notification':
                status_parts.append(f"üìä –ê–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–µ—Ç: <b>{len(self.active_coins)}</b>")
        else:
            status_parts.append("üî¥ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω")

        status_parts.append(f"üìã –ú–æ–Ω–µ—Ç –≤ —Å–ø–∏—Å–∫–µ: <b>{watchlist_manager.size()}</b>")

        status_parts.append("\n‚öô <b>–§–∏–ª—å—Ç—Ä—ã:</b>")
        status_parts.append(f"‚Ä¢ –û–±—ä—ë–º: ${config_manager.get('VOLUME_THRESHOLD'):,}")
        status_parts.append(f"‚Ä¢ –°–ø—Ä–µ–¥: {config_manager.get('SPREAD_THRESHOLD')}%")
        status_parts.append(f"‚Ä¢ NATR: {config_manager.get('NATR_THRESHOLD')}%")

        await update.message.reply_text(
            "\n".join(status_parts),
            reply_markup=self.main_keyboard,
            parse_mode=ParseMode.HTML
        )

    async def _handle_alerts(self, update: Update):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∞–ª–µ—Ä—Ç–æ–≤"""
        await self._stop_current_mode()

        stats = advanced_alert_manager.get_alert_stats()
        active_alerts = advanced_alert_manager.get_active_alerts()
        recent_history = advanced_alert_manager.get_alert_history(5)

        alerts_text = f"üö® <b>–°–∏—Å—Ç–µ–º–∞ –∞–ª–µ—Ä—Ç–æ–≤:</b>\n\n"
        alerts_text += f"üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:</b>\n"
        alerts_text += f"‚Ä¢ –í—Å–µ–≥–æ –∞–ª–µ—Ä—Ç–æ–≤: {stats['total_alerts']}\n"
        alerts_text += f"‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö: {stats['active_alerts']}\n"
        alerts_text += f"‚Ä¢ –û–±—â–∏—Ö —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–π: {stats['total_triggers']}\n\n"

        if active_alerts:
            alerts_text += f"üî¥ <b>–ê–∫—Ç–∏–≤–Ω—ã–µ –∞–ª–µ—Ä—Ç—ã ({len(active_alerts)}):</b>\n"
            for alert in active_alerts[:3]:
                alerts_text += f"‚Ä¢ {alert['title']} [{alert['severity'].upper()}]\n"
            if len(active_alerts) > 3:
                alerts_text += f"‚Ä¢ ... –∏ –µ—â–µ {len(active_alerts) - 3}\n"
            alerts_text += "\n"

        if recent_history:
            alerts_text += f"üìã <b>–ü–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è:</b>\n"
            for alert in recent_history:
                time_str = time.strftime("%H:%M", time.localtime(alert['timestamp']))
                alerts_text += f"‚Ä¢ {time_str} - {alert['title']} ({alert['symbol']})\n"
        else:
            alerts_text += f"‚úÖ <b>–ù–µ—Ç –Ω–µ–¥–∞–≤–Ω–∏—Ö —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏–π</b>\n"

        alerts_text += f"\nüí° –ê–ª–µ—Ä—Ç—ã —Ä–∞–±–æ—Ç–∞—é—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ"

        await update.message.reply_text(
            alerts_text,
            reply_markup=self.main_keyboard,
            parse_mode=ParseMode.HTML
        )

    async def _handle_reset_settings(self, update: Update):
        """–°–±—Ä–æ—Å –Ω–∞—Å—Ç—Ä–æ–µ–∫ –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é"""
        await self._stop_current_mode()

        config_manager.set('VOLUME_THRESHOLD', 1000)
        config_manager.set('SPREAD_THRESHOLD', 0.1)
        config_manager.set('NATR_THRESHOLD', 0.5)

        reset_message = (
            "üîÑ <b>–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–±—Ä–æ—à–µ–Ω—ã –∫ –∑–Ω–∞—á–µ–Ω–∏—è–º –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:</b>\n\n"
            f"üìä –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–±—ä—ë–º: <code>$1,000</code>\n"
            f"‚áÑ –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å–ø—Ä–µ–¥: <code>0.1%</code>\n"
            f"üìà –ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π NATR: <code>0.5%</code>"
        )

        await update.message.reply_text(
            reset_message,
            reply_markup=self.main_keyboard,
            parse_mode=ParseMode.HTML
        )

    async def _handle_back(self, update: Update):
        """–í–æ–∑–≤—Ä–∞—Ç –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é"""
        await update.message.reply_text(
            "üè† –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:",
            reply_markup=self.main_keyboard
        )

    # Handlers –¥–ª—è ConversationHandler
    async def add_coin_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç—ã"""
        text = update.message.text.strip()

        if text == "üîô –ù–∞–∑–∞–¥":
            await self._handle_back(update)
            return ConversationHandler.END

        from input_validator import input_validator

        if not input_validator.validate_symbol(text):
            await update.message.reply_text(
                "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã –∏ —Ü–∏—Ñ—Ä—ã (2-10 —Å–∏–º–≤–æ–ª–æ–≤).\n"
                "–ü—Ä–∏–º–µ—Ä—ã: BTC, ETH, DOGE",
                reply_markup=self.back_keyboard
            )
            return self.ADDING_COIN

        symbol = text.upper().replace("_USDT", "").replace("USDT", "")

        if not symbol or len(symbol) < 2:
            await update.message.reply_text(
                "‚ùå –ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Å–∏–º–≤–æ–ª. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:",
                reply_markup=self.back_keyboard
            )
            return self.ADDING_COIN

        if watchlist_manager.contains(symbol):
            await update.message.reply_text(
                f"‚ö† <b>{symbol}</b> —É–∂–µ –≤ —Å–ø–∏—Å–∫–µ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è.",
                reply_markup=self.main_keyboard,
                parse_mode=ParseMode.HTML
            )
            return ConversationHandler.END

        await update.message.reply_text("üîÑ –ü—Ä–æ–≤–µ—Ä—è—é –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –º–æ–Ω–µ—Ç—ã...")

        try:
            coin_data = await api_client.get_coin_data(symbol)

            if coin_data:
                watchlist_manager.add(symbol)
                await update.message.reply_text(
                    f"‚úÖ <b>{symbol}_USDT</b> –¥–æ–±–∞–≤–ª–µ–Ω–∞ –≤ —Å–ø–∏—Å–æ–∫ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è\n"
                    f"üí∞ –¢–µ–∫—É—â–∞—è —Ü–µ–Ω–∞: ${coin_data['price']:.6f}\n"
                    f"üìä 1–º –æ–±—ä—ë–º: ${coin_data['volume']:,.2f}\n"
                    f"üîÑ 1–º –∏–∑–º–µ–Ω–µ–Ω–∏–µ: {coin_data['change']:+.2f}%\n"
                    f"‚áÑ –°–ø—Ä–µ–¥: {coin_data['spread']:.2f}%",
                    reply_markup=self.main_keyboard,
                    parse_mode=ParseMode.HTML
                )
            else:
                await update.message.reply_text(
                    f"‚ùå <b>{symbol}_USDT</b> –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏.",
                    reply_markup=self.main_keyboard,
                    parse_mode=ParseMode.HTML
                )
        except Exception as e:
            bot_logger.error(f"–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–æ–Ω–µ—Ç—ã {symbol}: {e}")
            await update.message.reply_text(
                f"‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ <b>{symbol}</b>. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                reply_markup=self.main_keyboard,
                parse_mode=ParseMode.HTML
            )

        return ConversationHandler.END

    async def remove_coin_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ —É–¥–∞–ª–µ–Ω–∏—è –º–æ–Ω–µ—Ç—ã"""
        text = update.message.text.strip()

        if text == "üîô –ù–∞–∑–∞–¥":
            await self._handle_back(update)
            return ConversationHandler.END

        symbol = text.upper().replace("_USDT", "").replace("USDT", "")

        if watchlist_manager.remove(symbol):
            await update.message.reply_text(
                f"‚úÖ <b>{symbol}</b> —É–¥–∞–ª–µ–Ω–∞ –∏–∑ —Å–ø–∏—Å–∫–∞ –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è.",
                reply_markup=self.main_keyboard,
                parse_mode=ParseMode.HTML
            )
        else:
            await update.message.reply_text(
                f"‚ùå <b>{symbol}</b> –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ —Å–ø–∏—Å–∫–µ.",
                reply_markup=self.main_keyboard,
                parse_mode=ParseMode.HTML
            )

        return ConversationHandler.END

    async def volume_setting_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –æ–±—ä—ë–º–∞"""
        text = update.message.text.strip()

        if text == "üîô –ù–∞–∑–∞–¥":
            await self._handle_settings(update)
            return ConversationHandler.END

        try:
            value = int(text)
            if value < 100:
                await update.message.reply_text(
                    "‚ùå –û–±—ä—ë–º –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –Ω–µ –º–µ–Ω–µ–µ $100. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:",
                    reply_markup=self.back_keyboard
                )
                return self.SETTING_VOLUME

            config_manager.set('VOLUME_THRESHOLD', value)
            await update.message.reply_text(
                f"‚úÖ <b>–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –æ–±—ä—ë–º —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω:</b> ${value:,}",
                reply_markup=self.main_keyboard,
                parse_mode=ParseMode.HTML
            )
        except ValueError:
            await update.message.reply_text(
                "‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:",
                reply_markup=self.back_keyboard
            )
            return self.SETTING_VOLUME

        return ConversationHandler.END

    async def spread_setting_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–ø—Ä–µ–¥–∞"""
        text = update.message.text.strip()

        if text == "üîô –ù–∞–∑–∞–¥":
            await self._handle_settings(update)
            return ConversationHandler.END

        try:
            value = float(text)
            if value < 0 or value > 10:
                await update.message.reply_text(
                    "‚ùå –°–ø—Ä–µ–¥ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 0 –¥–æ 10%. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:",
                    reply_markup=self.back_keyboard
                )
                return self.SETTING_SPREAD

            config_manager.set('SPREAD_THRESHOLD', value)
            await update.message.reply_text(
                f"‚úÖ <b>–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π —Å–ø—Ä–µ–¥ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω:</b> {value}%",
                reply_markup=self.main_keyboard,
                parse_mode=ParseMode.HTML
            )
        except ValueError:
            await update.message.reply_text(
                "‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:",
                reply_markup=self.back_keyboard
            )
            return self.SETTING_SPREAD

        return ConversationHandler.END

    async def natr_setting_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç—á–∏–∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ NATR"""
        text = update.message.text.strip()

        if text == "üîô –ù–∞–∑–∞–¥":
            await self._handle_settings(update)
            return ConversationHandler.END

        try:
            value = float(text)
            if value < 0 or value > 20:
                await update.message.reply_text(
                    "‚ùå NATR –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –æ—Ç 0 –¥–æ 20%. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:",
                    reply_markup=self.back_keyboard
                )
                return self.SETTING_NATR

            config_manager.set('NATR_THRESHOLD', value)
            await update.message.reply_text(
                f"‚úÖ <b>–ú–∏–Ω–∏–º–∞–ª—å–Ω—ã–π NATR —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω:</b> {value}%",
                reply_markup=self.main_keyboard,
                parse_mode=ParseMode.HTML
            )
        except ValueError:
            await update.message.reply_text(
                "‚ùå –í–≤–µ–¥–∏—Ç–µ —á–∏—Å–ª–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:",
                reply_markup=self.back_keyboard
            )
            return self.SETTING_NATR

        return ConversationHandler.END

    async def _queue_message(self, message_data: Dict[str, Any]):
        """–î–æ–±–∞–≤–ª—è–µ—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –æ—á–µ—Ä–µ–¥—å –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏"""
        try:
            if self._message_queue is None:
                self._message_queue = asyncio.Queue()

            await self._message_queue.put(message_data)
            bot_logger.debug("üì§ –°–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–æ –≤ –æ—á–µ—Ä–µ–¥—å")
        except Exception as e:
            bot_logger.error(f"–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –≤ –æ—á–µ—Ä–µ–¥—å: {e}")

    def setup_application(self):
        """–ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç Telegram –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"""
        from telegram.error import Conflict, NetworkError, TimedOut

        builder = Application.builder()
        builder.token(self.token)
        builder.connection_pool_size(4)
        builder.pool_timeout(15.0)
        builder.read_timeout(20.0)
        builder.write_timeout(20.0)

        async def error_handler(update, context):
            error = context.error

            if isinstance(error, Conflict):
                bot_logger.warning("–ö–æ–Ω—Ñ–ª–∏–∫—Ç Telegram API - –≤–æ–∑–º–æ–∂–Ω–æ –∑–∞–ø—É—â–µ–Ω –¥—Ä—É–≥–æ–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞")
                return
            elif isinstance(error, (NetworkError, TimedOut)):
                bot_logger.debug(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞ Telegram: {type(error).__name__}")
                return
            else:
                bot_logger.error(f"–û—à–∏–±–∫–∞ Telegram –±–æ—Ç–∞: {error}")

        self.app = builder.build()
        self.app.add_error_handler(error_handler)

        conv_handler = ConversationHandler(
            entry_points=[
                MessageHandler(filters.TEXT & ~filters.COMMAND, self.button_handler)
            ],
            states={
                self.ADDING_COIN: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.add_coin_handler)
                ],
                self.REMOVING_COIN: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.remove_coin_handler)
                ],
                self.SETTING_VOLUME: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.volume_setting_handler)
                ],
                self.SETTING_SPREAD: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.spread_setting_handler)
                ],
                self.SETTING_NATR: [
                    MessageHandler(filters.TEXT & ~filters.COMMAND, self.natr_setting_handler)
                ]
            },
            fallbacks=[
                CommandHandler("start", self.start_handler),
                MessageHandler(filters.Regex("^üîô –ù–∞–∑–∞–¥$"), self._handle_back)
            ],
            per_message=False
        )

        self.app.add_handler(CommandHandler("start", self.start_handler))
        self.app.add_handler(conv_handler)

        return self.app

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
telegram_bot = TradingTelegramBot()